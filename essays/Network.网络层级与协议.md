# 网络层级与协议

## 零、参考资料
* http://www.52im.net/thread-1095-1-1.html

## 一、概述
* 在中学刚刚接触计算机的时候，老师讲的网络分层还是 OSI 七层模型(应用、表示、会话、传输、网络、数据链路、物理)，如今随着时间的发展，表示层和会话层渐渐融入了应用层，就诞生了更适合学习的五层模型(应用、传输、网络、数据链路、物理)。本文记录各层的具体分工，以及各层常用的协议和功能

## 二、物理层
* 有些地方也叫实体层，这一层上基本都是硬件，比如光缆、电缆、双绞线、无线电波等都可以算是，主要作用是负责传递 0/1 信号，没啥特别需要注意的

## 三、数据链路层
* 有些地方也叫链接层。单纯的 0/1 流是没有多大意义的，必须规定解读的方式，比如：多少个信号才能算一组？每个信号位的意义是什么？链路层就是干的这个活

### (一)、以太网协议
* 早期的时候，每家公司都有自己的电信号分组方式。其后，世界范围内逐渐形成了一种叫做"以太网"(Ethernet)的协议，并将其作为统一标准  
* 以太网协议规定：一组电信号构成一个数据包，这个数据包叫做"帧"(Frame)，每一帧分为两个部分：标头(Head)和数据(Data)
  * "标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容
  * "标头"的长度，固定为 18 字节。"数据"的长度，最短为 46 字节，最长为 1500 字节。因此，整个"帧"最短为 64 字节，最长为  1518字节。如果数据很长，就必须分割成多个帧进行发送。

### (二)、Mac 地址
* 以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址  
* 每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示  
* 如：00-B0-D0-86-BB-F7，前6个数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了
> MAC 地址，有时候称之为 物理地址 或者 本地地址

### (三)、广播
* 定义地址只是第一步，后面还有更多的步骤：
#### (1) 一块网卡怎么会知道另一块网卡的 MAC 地址？
* 有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的 MAC 地址，然后才能发送

#### (2) 有了 MAC 地址，系统怎样才能把数据包准确送到接收方？
* 以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送(即 广播，broadcasting)，让每台计算机自己判断，是否为接收方。

## 四、网络层
* 我们知道，尽管全球网络是最大的网络，但是并不意味着每台终端是直接连入这个最大的网络的，通常，我们会接入一个小一点的网络，比如一个小型路由器就能组建出一个小型网络，然后这个小网络作为统一出口接入到地区运营商的稍大一点的网络，然后这个网络呢又有一个统一出口接入到再大一点的网络...这样一层一层的子网络构成了全球网络  
* 为什么要这样设计，和以太网的广播有关，比如连接同一个路由器的两台终端之间的通信，只需要在这个小网络内广播数据包就行，没必要让其他子网络知道；而且，要构建能直连的网络，带宽啥的得消耗多少物质材料，这是完全的浪费  
* 于是，就需要找到一种方法，能够区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。（"路由"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及）遗憾的是，MAC 地址本身无法做到这一点。它只与厂商有关，与所处网络无关  
* 这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"  
* 于是，"网络层"出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

### (一)、IP协议
#### (1) IP
* 规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为 IP 地址。目前，广泛采用的是 IP 协议第四版，简称 IPv4，由 32 个二进制位组成，如 172.16.254.1(十进制表示)
* 这个 IP 地址也分为两个部分，前一部分代表网络，后一部分代表主机，如上面的那个 IP，假定前 24 位代表网络，最后 8 位代表主机，那么处于同一个子网络的电脑，他们分配到的 IP 的前 24 位应该是一样的，即 172.16.254.1 和 172.16.254.x(x 最大为 255)是处于同一个子网络中

#### (2)子网掩码
* 但是，怎么才能判断出一个 IP 地址中哪些是网络部分，哪些是主机部分呢？需要结合 子网掩码(subnet mask) 来运算判断
* 所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于 IP 地址，也是一个 32 位二进制数字，它的网络部分全部为 1，主机部分全部为 0。比如，IP 地址 172.16.254.1，如果已知网络部分是前 24 位，主机部分是后 8 位，那么子网络掩码就是 11111111.11111111.11111111.00000000，写成十进制就是 255.255.255.0
* 这样就能通过将两个 IP 分别和子网掩码进行 AND 运算，比较结果是否一致，一致则表明在同一子网络呢，反之则不再
* 当然，子网掩码也分为默认的和自定义的，默认的就三个：255.0.0.0(A 类) / 255.255.0.0(B 类) / 255.255.255.0(C 类)；自定义的也有对应的算法，不详述

### (二)、IP 数据包
* 根据 IP 协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含 MAC 地址，并没有 IP 地址的栏位，那么该如何加上这些信息呢？直接将整个 IP 数据包作为以太网数据包的"数据"部分，再加上"标头"即可形成一个标准的 以太网数据包
* 一个标准的 IP 数据包，"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。IP 数据包的"标头"部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65,535 字节。因此，理论上，一个 IP 数据包的"数据"部分，最长为 65,515 字节。前面说过，以太网数据包的"数据"部分，最长只有 1500 字节。因此，如果 IP 数据包超过了 1500 字节，它就需要分割成几个以太网数据包，分开发送

### (三)、ARP 协议
> ARP 协议是工作在网络层的协议
* 这个协议的功能是根据 IP 地址来寻找目标主机的 MAC 地址的协议，分为两种情况：
  * 两台主机在同一个子网络内，则可以使用这个协议：一台主机发出一个数据包(包含在以太网数据包中)，其中包含它需要查询的主机的 IP 地址，在对方的 MAC 地址栏内，填写的是 FF:FF:FF:FF:FF:FF，这代表的是一个"广播"地址，路由器或者其他设备解析出来到这个时，会把数据包发给子网络的所有主机(即子网络的所有主机都会收到这个数据包)，每个主机从数据包中取出 IP 地址，然后和自身的 IP 进行比对，如果命中，向发出方给出回复，报告自己的 MAC 地址，否则丢弃这个数据包
  * 两台主机不在同一个子网络内，则无法按照上面的流程去查询，只能把数据包发给网关(gateway)，让网关去进一步处理，当然，这种情况下，发出方需要知道的是自己所在子网的网关的 MAC 地址

### (四)、IPv6 协议
* IPv6 协议是第 6 版的 IP 协议，解决了 IPv4 的一些缺点，也大大拓展了 IPv4 的功能，因此，上面的 子网掩码 和 ARP 协议均不适用于 IPv6 协议

## 五、传输层
* 有了 IP 和 MAC 地址之后，两台主机之间就能建立通信。但是主机上运行着各种各样的程序(进程)，都在运用着网络，当主机接受都一个数据包，那么这个数据包最后应该分配给哪个程序(进程)呢？
* 于是有了一个"端口"(port)的参数，一个应用程序如果想要使用网络进行通信，那么它就会随机选用一个端口，那么主机在解析从网络上的数据包的时候，就能根据端口协议，把数据包分配给对应的进程(程序)处理
* 综合而言，"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了

### (一)、UDP 协议
* 我们在数据包中加入端口信息，就需要用到传输层协议，最简单的实现叫做 UDP 协议，也是"标头" + "数据"两部分："标头"部分主要定义了发出端口和接收端口，"数据"部分就是具体的内容。然后，整个 UDP 数据包就能作为 IP 数据包的"数据"部分进行封装
* UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包

### (二)、TCP 协议
* UDP 协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的 UDP 协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了
* 因此，TCP 协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源
* TCP 数据包和 UDP 数据包一样，都是内嵌在 IP 数据包的"数据"部分。TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割

## 六、应用层
* 应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。"应用层"的作用，就是规定应用程序的数据格式。
* 举例来说，TCP 协议可以为各种各样的程序传递数据，比如 Email、WWW、FTP 等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分
