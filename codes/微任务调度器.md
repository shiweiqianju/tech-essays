# 微任务调度器 - Scheduler

## 零、参考
* [从0到1实现通用微任务调度器：理解前端异步调度核心](https://juejin.cn/post/7588149079416864822)


### 一、（最小版）核心类实现
```TS
// TS 实现
type TaskToQueue = () => void;
type Unsubscribe = () => void;

// 核心类实现（最小版）
class MicroScheduler {
  // 任务队列
  private readonly _taskQueue = new Set<TaskToQueue>();

  // 是否已经调度任务执行(防重复)
  private _isFlushScheduled: boolean = false;

  // 是否正在执行任务(避免嵌套执行)
  private _isFlushing: boolean = false;

  /**
   * 批量执行所有任务
   */
  private _executeTasks(): void {
    if (this._isFlushing) return;

    this._isFlushing = true;
    this._taskQueue.forEach(task => {
      task();
      this._taskQueue.delete(task);
    });
    this._isFlushing = false;
  }

  /**
   * 调度任务执行到微任务队列（核心：防重复调度）
   */
  private _scheduleFlush(): void {
    // 已调度/正在执行，直接返回
    if (this._isFlushing || this._isFlushScheduled) return;

    this._isFlushScheduled = true;
    queueMicrotask(() => { // Web API
      this._isFlushScheduled = false;
      this._executeTasks();
    })
  }

  // 入栈，并触发调度
  enqueue(task: TaskToQueue): void {
    this._taskQueue.add(task);
    this._scheduleFlush();
  }
}

const scheduler = new MicroScheduler();

// 添加2个任务（故意重复添加，测试去重）
const task1 = () => console.log('执行任务1');

scheduler.enqueue(task1);
scheduler.enqueue(task1); // 重复添加，Set会自动去重
scheduler.enqueue(() => console.log('执行任务2'));
```
```js
// JS 实现
// 核心类实现（最小版）
class MicroScheduler {
  constructor() {
    // 任务队列
    this._taskQueue = new Set();
    // 是否已经调度任务执行(防重复)
    this._isFlushScheduled = false;
    // 是否正在执行任务(避免嵌套执行)
    this._isFlushing = false;
  }
  /**
   * 批量执行所有任务
   */
  _executeTasks() {
    if (this._isFlushing) return;

    this._isFlushing = true;
    this._taskQueue.forEach(task => {
      task();
      this._taskQueue.delete(task);
    });
    this._isFlushing = false;
  }
  /**
   * 调度任务执行到微任务队列（核心：防重复调度）
   */
  _scheduleFlush() {
    // 已调度/正在执行，直接返回
    if (this._isFlushing || this._isFlushScheduled) return;

    this._isFlushScheduled = true;
    queueMicrotask(() => {
      this._isFlushScheduled = false;
      this._executeTasks();
    });
  }
  // 入栈，并触发调度
  enqueue(task) {
    this._taskQueue.add(task);
    this._scheduleFlush();
  }
}

const scheduler = new MicroScheduler();
// 添加2个任务（故意重复添加，测试去重）
const task1 = () => console.log('执行任务1');

scheduler.enqueue(task1);
scheduler.enqueue(task1); // 重复添加，Set会自动去重
scheduler.enqueue(() => console.log('执行任务2'));
```

## 二、全功能版本
```TS
// TS 实现
type TaskToQueue = () => void;
type Unsubscribe = () => void;
type Callback = () => void;

// 声明全局 queueMicrotask 类型（兼容 Node.js 和浏览器环境）
// declare const queueMicrotask: ((callback: Callback) => void) | undefined;

// 核心类实现（最小版）
class MicroScheduler {
  // 任务队列
  private readonly _taskQueue = new Set<TaskToQueue>();

  // 是否已经调度任务执行(防重复)
  private _isFlushScheduled: boolean = false;

  // 是否正在执行任务(避免嵌套执行)
  private _isFlushing: boolean = false;

  // 执行前/后回调队列
  private readonly _beforeFlushCallbacks = new Set<Callback>();
  private readonly _afterFlushCallbacks = new Set<Callback>();

  // 固定的微任务Promise（仅初始化一次）
  private readonly _microtaskPromise = Promise.resolve<void>(undefined);

  // 兼容后的微任务执行函数（适配无 queueMicrotask 的环境）
  private readonly _queueMicrotaskFn: (callback: Callback) => void;

  // 公开只读属性：外部可await
  readonly tick = this._microtaskPromise;

  constructor() {
      this._queueMicrotaskFn = typeof queueMicrotask !== 'undefined' ? queueMicrotask : cb => this._microtaskPromise.then(cb);
  }

  /**
   * 批量执行所有任务
   */
  private _executeTasks(): void {
    if (this._isFlushing) return;

    this._isFlushing = true;

    try {
      // 1. 执行前置回调
      const beforeCallbacks = Array.from(this._beforeFlushCallbacks);

      beforeCallbacks.forEach(cb => {
        try {
          cb();
        } catch(err) { // 捕获单个任务异常，不影响其他任务执行
          console.error('调度器执行前置回调失败:', err);
        }
      });

      // 2. 执行所有任务（复制后遍历，避免迭代时修改队列）
      const tasks = Array.from(this._taskQueue);

      tasks.forEach(task => {
        try {
          task();
        } catch (err) { // 捕获单个任务异常，不影响其他任务执行
          console.error('调度器执行任务失败:', err);
        }
    
        this._taskQueue.delete(task);
      });
    } finally { // 无论是否出错，都重置状态 + 执行后置回调
      const afterCallbacks = Array.from(this._afterFlushCallbacks);

      afterCallbacks.forEach((cb) => {
        try {
          cb();
        } catch (e) {
          console.error('调度器执行后置回调失败:', e);
        }
      });
      this._isFlushing = false;
    }
  }

  /**
   * 调度任务执行到微任务队列（核心：防重复调度）
   */
  private _scheduleFlush(): void {
    // 已调度/正在执行，直接返回
    if (this._isFlushing || this._isFlushScheduled) return;

    this._isFlushScheduled = true;
    queueMicrotask(() => {
      this._isFlushScheduled = false;
      this._executeTasks();
    })
  }

  // 入栈，并触发调度
  enqueue(task: TaskToQueue): void {
    if (typeof task !== 'function') throw new TypeError('enqueue 必须传入函数类型的任务!');

    this._taskQueue.add(task);
    this._scheduleFlush();
  }

  /**
   * 默认异步触发任务批量执行（放入微任务队列）
   * 多次调用仅会触发一次微任务，避免重复执行
   */
  flush(): void {
    this._scheduleFlush();
  }

  /**
   * 同步触发任务执行（立即执行，不等待微任务）
   */
  flushSync(): void {
    this._executeTasks();
  }

  /**
   * 注册「任务执行前」的回调
   * 
   * @param callback 执行前的回调函数
   * @returns 取消回调的函数
   */
  onBeforeFlush(callback: Callback): Unsubscribe {
    return this._registerCallback(this._beforeFlushCallbacks, callback);
  }

  /**
   * 注册「任务执行后」的回调
   * 
   * @param callback 执行后的回调函数
   * @returns 取消回调的函数
   */
  onAfterFlush(callback: Callback): Unsubscribe {
    return this._registerCallback(this._afterFlushCallbacks, callback);
  }

  /**
   * 注册回调并返回取消函数（复用逻辑）
   * 
   * @param callbacks 回调队列
   * @param callback 要注册的回调函数
   * @returns 取消回调的函数
   */
  private _registerCallback(callbacks: Set<Callback>, callback: Callback): Unsubscribe {
    if (typeof callback !== 'function') throw new TypeError('回调必须是函数类型');

    callbacks.add(callback);

    return () => callbacks.delete(callback);
  }
}

const scheduler = new MicroScheduler();
```

```js
// js 实现
"use strict";
// 声明全局 queueMicrotask 类型（兼容 Node.js 和浏览器环境）
// declare const queueMicrotask: ((callback: Callback) => void) | undefined;
// 核心类实现（最小版）
class MicroScheduler {
  constructor() {
      // 任务队列
      this._taskQueue = new Set();
      // 是否已经调度任务执行(防重复)
      this._isFlushScheduled = false;
      // 是否正在执行任务(避免嵌套执行)
      this._isFlushing = false;
      // 执行前/后回调队列
      this._beforeFlushCallbacks = new Set();
      this._afterFlushCallbacks = new Set();
      // 固定的微任务Promise（仅初始化一次）
      this._microtaskPromise = Promise.resolve(undefined);
      // 公开只读属性：外部可await
      this.tick = this._microtaskPromise;
      this._queueMicrotaskFn = typeof queueMicrotask !== 'undefined' ? queueMicrotask : cb => this._microtaskPromise.then(cb);
  }
  /**
   * 批量执行所有任务
   */
  _executeTasks() {
    if (this._isFlushing) return;

    this._isFlushing = true;

    try {
      // 1. 执行前置回调
      const beforeCallbacks = Array.from(this._beforeFlushCallbacks);

      beforeCallbacks.forEach(cb => {
        try {
          cb();
        }
        catch (err) { // 捕获单个任务异常，不影响其他任务执行
          console.error('调度器执行前置回调失败:', err);
        }
      });

      // 2. 执行所有任务（复制后遍历，避免迭代时修改队列）
      const tasks = Array.from(this._taskQueue);

      tasks.forEach(task => {
        try {
          task();
        }
        catch (err) { // 捕获单个任务异常，不影响其他任务执行
          console.error('调度器执行任务失败:', err);
        }
        this._taskQueue.delete(task);
      });
    } finally { // 无论是否出错，都重置状态 + 执行后置回调
      const afterCallbacks = Array.from(this._afterFlushCallbacks);

      afterCallbacks.forEach((cb) => {
        try {
          cb();
        }
        catch (e) {
          console.error('调度器执行后置回调失败:', e);
        }
      });
      this._isFlushing = false;
    }
  }
  /**
   * 调度任务执行到微任务队列（核心：防重复调度）
   */
  _scheduleFlush() {
    // 已调度/正在执行，直接返回
    if (this._isFlushing || this._isFlushScheduled) return;

    this._isFlushScheduled = true;
    queueMicrotask(() => {
      this._isFlushScheduled = false;
      this._executeTasks();
    });
  }
  // 入栈，并触发调度
  enqueue(task) {
    if (typeof task !== 'function') throw new TypeError('enqueue 必须传入函数类型的任务!');

    this._taskQueue.add(task);
    this._scheduleFlush();
  }
  /**
   * 默认异步触发任务批量执行（放入微任务队列）
   * 多次调用仅会触发一次微任务，避免重复执行
   */
  flush() {
    this._scheduleFlush();
  }
  /**
   * 同步触发任务执行（立即执行，不等待微任务）
   */
  flushSync() {
    this._executeTasks();
  }
  /**
   * 注册「任务执行前」的回调
   *
   * @param callback 执行前的回调函数
   * @returns 取消回调的函数
   */
  onBeforeFlush(callback) {
    return this._registerCallback(this._beforeFlushCallbacks, callback);
  }
  /**
   * 注册「任务执行后」的回调
   *
   * @param callback 执行后的回调函数
   * @returns 取消回调的函数
   */
  onAfterFlush(callback) {
    return this._registerCallback(this._afterFlushCallbacks, callback);
  }
  /**
   * 注册回调并返回取消函数（复用逻辑）
   *
   * @param callbacks 回调队列
   * @param callback 要注册的回调函数
   * @returns 取消回调的函数
   */
  _registerCallback(callbacks, callback) {
    if (typeof callback !== 'function') throw new TypeError('回调必须是函数类型');

    callbacks.add(callback);

    return () => callbacks.delete(callback);
  }
}
const scheduler = new MicroScheduler();
```
